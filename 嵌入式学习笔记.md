# 嵌入式学习 每周总结



<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>

# 第一周

<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>





# 一、 头文件
## #include <>的搜索顺序：
1. 系统标准头文件目录：

    1.编译器内置的标准库路径

    2.操作系统提供的系统头文件路径

2. 编译器指定的包含路径：

    1.通过 -I 选项添加的目录

    2.环境变量指定的路径

## #include " "的搜索顺序：
1. 当前文件所在目录

2. 当前编译单元所在目录

3. 编译器指定的包含路径（与 #include＜＞ 共享）

4. 系统标准头文件目录

一句话总结，<> 从系统库的默认路径中查找，存在就打开，否则失效，“” 从当前项目中找对应的头文件，若找不到就从系统库的默认路径中查找，如果还找不到就失效。

**记住这个简单的原则：系统及第三方库用 ＜＞，项目自己的文件用 ""**

# 二、 注释：
## 单行注释 ： // 
    添加快捷键：ctrl + k + c
    
    删除快捷键：ctrl + k + u

## 多行注释 ： /* */ 

# 三、 变量：
## 概念：
在内存空间中申请一片可以自己操作的空间，大小根据类型来定。

## 内存大小：
bit 、Byte ； 1B=8b ；KB,MB,GB,TB,PB,EB,ZB

## 命名规则：
        1. 只能有数字、字母、下划线组成。
    
        2. 一般以字母开头，下划线开头有特殊含义，不能由数字开头。
    
        3. 不能和关键字重名。
      
      	4. 变量名要见名知意。
    
        5. 变量名过长可用下划线或驼峰式(首单词的字母都小写，后面的每一个新单词首字母大写)命名 。               
    
        下划线：student_age
    
        驼峰式：studentAge
# 四、常量：


1、 包括**整数常量**、**浮点常量**、**字符常量**等，不可被赋值运算符更改。

**字符常量**：使用单引号’，‘a’

**字符串常量**：使用双引号”，“asdf”

字符串字面量不能直接和字符字面量直接比较。

2、在 C 中，有两种简单的定义常量的方式：

    使用 #define 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。
    
    使用 const 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。
**注：const声明常量需要在一个语句中完成。**

![alt text](.\day2\note\569ee770273e429898b00aaad0b2f4cd.png)
![alt text](.\day2\note\2b04b3f16172420c922e634f12301b63.png)


## #define 与 const 区别
#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

#define 预处理指令和 const 关键字在定义常量时有一些区别：

**替换机制**：#define 是进行简单的文本替换，而 const 是声明一个具有类型的常量。#define 定义的常量在编译时会被直接替换为其对应的值，而 const 定义的常量在程序运行时会分配内存，并且具有类型信息。

**类型检查**：#define 不进行类型检查，因为它只是进行简单的文本替换。而 const 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。

**作用域**：#define 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 const 定义的常量具有块级作用域，只在其定义所在的作用域内有效。

**调试和符号表**：使用 #define 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 const 定义的常量会在符号表中有相应的条目，有助于调试和可读性。

## 浮点类型：
double和lfloat

float精确范围：7位有效数字

double精确范围：15~16位有效数字

# 五、 字符型：
ASCII码表：
![alt text](.\day2\note\55e44d264e2b4dd0b4bb1fdcb8b935ea.png)


## 不可见字符【0-32】、【127】：灰色部分
## 可见字符：
        数字字符【48-57】
    
        大写字母【65-90】
    
        小写字母【97-122】
    
        注：大小写字母差值为32，大写字母数值较小。

## 转义字符：
转义字符可以将一些具有特殊含义的字符转化为普通字符使用，或者也可以将一些普通字符转化为具有特殊含义的字符来使用
    \n：换行符
    \t：水平制表符
    \\：输出反斜杠
    \“：输出双引号


# 六、 输入输出：
## 单个字符输入输出：
getchar():获取一个字符，包括空格、换行。

putchar():输出一个字符到控制台。

常见例子：大写字母换成小写字母：
```
    int c;
    while ((c = getchar()) != '\n'){
        if (c >= 65 && c <= 90) {
            c = c + 32;
        }
        if (c != '\n') {
            printf("%c", c);
        }
    }
```
## 标准输入输出：
scanf():  scanf(字符串,变量地址); //字符串中一般要写接受的数据的类型，比如%d 有符号整型

printf():

## printf 参数
在printf中，有一个双引号引起来的常量字符串，里面用%做占位符，每个占位符都要在后面加上对应的参数，根据不同的类型，将数据解读成不同的样式。

### 进制：
        %u：无符号十进制
    
        %o：无符号八进制
    
        %x：无符号十六进制
    
        %d：有符号十进制

### 类型：
        %i：整型
    
        %f：浮点型，控制的是：保留【小数点后 n 位】，默认值是 6 位；对最后一位遵循 四舍五入 规则；只会以「普通小数格式」输出，永远不会触发科学计数法，哪怕是极大数 / 极小数。
    
        %c：字符型
    
        %s：字符串型
    
        %p：指针类型

### 科学计数法：
       %g 控制的是：保留【n 位有效数字】，默认值是 6 位。
    
        自动二选一格式：阈值为 数值数值在此区间内 → 用「普通小数格式」输出；
    
                                     数值 < 10−4 或 数值 > 106 → 用「科学计数法格式」输出；
    
        自动精简去 0：去掉小数点后无意义的末尾 0，这是%g最实用的特性；
    
        自动去小数点：如果去 0 后小数点后没有数字，直接去掉小数点本身；
    
        四舍五入规则：对最后一位有效数字正常四舍五入。

# 七、 位运算
##    |:按位或
        两个数字的二进制对应的位置只要有1结果就是1，否则为0（有1则1）
示例：
```
    //练习1：大写转小写
    char ch1;
    while ((ch1 = getchar()) != '\n') {
        ch1 |= 0x20;
        printf("%c", ch1);
    }
```
##   &:按位与
        两个数字的二进制对应的位置只要有0，结果就为0，否则为1（有0则0）

示例：
```
    //练习2：小写转大写
    char ch2;
    while ((ch2 = getchar()) != '\n') {
        ch2 &= ~0x20;
        printf("%c", ch2);
    }
```
##    ^:按位异或
        两个数字的二进制对应的位置数字如果相同，结果就为0，如果不同结果为1（同0异1）
示例：
```
    //练习3:大写转小写，小写转大写
    char ch3;
    while ((ch3 = getchar()) != '\n') {
        ch3 ^= 0x20;
        printf("%c", ch3);
    }
```
##    << 按位左移
        将一个数字的对应二进制的所有的位，向左侧移动一位，高位溢出，低位补零
        注意点：
            1、溢出的数字直接消失，不会再被找回来（高位溢出之后，不能再用右移取回）
            2、左移相当于将当前的数字 乘以 2^n，  比如说数字3，左移4位，就相当于 3 * 2^4


##   \>> 按位右移
        将一个数字的对应二进制的所有位向右移动一位，低位溢出，高位补零
        右移相当于将当前的数字除以2^n，比如说数字10，右移2位，相当于10 / 2^2

##    ~按位取反
        将数字对应的二进制的各个位，进行取反，原来是0就换成1，原来是1就换成0
        比如：0000 1010(10)  取反 1111 0101（245）


##  原码、反码、补码

    原码：
    最高位是符号位，0表示正数，1表示负数
    
    反码：
    最高位是符号位，0表示正数，1表示负数，正数的反码等于它本身，负数的反码除了符号位以外，其余各位取反
    
    补码：
    最高位是符号位，0表示正数，1表示负数，正数的补码等于它本身，负数的补码是反码+1


    原码转补码：正数不变，负数除了符号位以外，其余各位取反+1
    补码转原码：正数不变，负数除了符号位以外，其余各位取反+1
    注：即数值位从右往左数第一个‘1’开始的左边全部取反。

按位运算符可以和赋值运算符放一起：
    |=、&=、<<=、>>=、^=、=

## 运算符优先级
![alt text](.\day3\note\1.png)


# 八、左值右值

##    左值
        可以出现在赋值运算符左边的，也可以出现在赋值运算符的右边，标识了一个可以存储结果的地点（内存空间）
        程序在编译的时候，编译器会为每一个变量都分配一个地址，所以变量一般都是左值，地址在编译的时候是可知的。

##    右值
        出现在赋值运算符右边的，它必须有一个特定的值。
        在变量中存储的那个值，一般都是右值，只有在程序运行的时候才可知。
        右值是一个字面量或者一个数字或者一个常量，它在内存中并没有一个具体的地址

大多数表达式都具有右值的属性，因为每个变量所标识的空间地址都会存储一个具体的值，只要表达式不出错，那么它就会获取到一个特定的值。


# 九、类型转换
## 隐式类型转换
    从低等级到高等级的类型转换就是隐式类型转换，例如：int -> unsigned int、 long->unsigned long、float->double。
## 强制类型转换
    (类型说明符)(表达式)：一般后面是一个表达式的时候，需要加括号先计算表达式结果，再强转
    (类型说明符)变量/值：如果后面是一个变量或者一个具体的数字，可以加也可以不加，没有影响


# 十、 选择语句
## if语句
    语法:
```
if (条件表达式) {
        执行语句;
} else if (条件表达式) {
    执行语句;
} ..... //中间以及最后的语句可有可无
 else {
    执行语句;
}
```

总结：
    if语句会自上而下进行判断，如果有已经成立的条件，不会继续向下判断了
    所有的分支都不成立的时候，去else
    else if  或者 else 不是必须的，依据实际的场景看是否需要


## switch语句
主要是对一个输入数据进行判等的操作。
语法：
```
switch(整型/枚举){
    case 常量1：
         执行语句；
         break；
    case 常量2：
         执行语句；
         break；
    case 常量3：
         执行语句；
         break；
    case 常量4：
         执行语句；
         break；
    ......
    default:
         执行语句；
}
```

执行思路：将switch括号中的值和每一个case后的常量值进行对比，如果都匹配的就执行相应的语句，否则就执行default

注意：
    每一个case后面都应该有一个break，为了防止穿透执行，如果没有break，当满足了某一个case之后，会持续向下执行case语句，直到遇到break或者整个switch语句结束为止。
    switch中的所有case后的常量值都不可以重复。

## if语句和switch语句的使用场景
    if语句一般用于一个范围判断
    switch语句一般用于一个确定的值进行相等判断，主要用于代码的整理，更加清除的梳理代码结构

# 十一、 循环语句

## for循环

### 语法：
```
for (循环变量;循环条件;操作表达式){
    循环体;
}
```

### 执行思路：
    1、先执行循环变量
    2、判断循环条件
    3、执行循环体
    4、执行操作表达式
    5、判断循环条件（满足继续循环，不满足退出循环）

### 示例：
```
	//练习1：求1-20偶数和
	int sum = 0;
	for (int i = 1; i <= 20; i++) {
		if (i % 2 == 0)
		{
			sum += i;
		}
	}
	printf("%d", sum);

	//优化版本
	for (int i = 2; i <= 20; i += 2) {//这里也可通过乘2实现
		sum += i;
	}
	printf("%d", sum);

	//练习2：10阶乘
	long int result = 1;//虽然不会溢出，以防万一，开大点
	for (int i = 1; i <= 10; i++) {
		result *= i;
	}
	printf("%ld", result);


	//练习3：1-10阶乘和
	long int result = 1;
	long int sum = 0;
	for (int i = 1; i <= 10; i++) {
		result *= i;
		sum += result;
	}
	printf("%d", sum);

	//练习4：
	int m = 0, n = 0;
	scanf("%d%d", &m, &n);
	int sum = 0;
	int temp = 0;
	for (int i = 0; i < m; i++) {
		temp = temp * 10 + n;
		//printf("%d ", temp);
		sum += temp;
	}
	printf("%d", sum);

	//练习5：求数字各个位之和
	int num;
	scanf("%d", &num);
	int sum = 0;
	//for (; num != 0;) {
	//	sum += num % 10;
	//	num /= 10;
	//}
	for (int i = num; i != 0; i /= 10) {
		sum += i % 10;
	}
	printf("%d", sum);
```

## while循环

### 语法：
```
while （循环条件）{
    循环体;
}
```

### 执行思路：
    当循环条件为真的时候就执行循环体，否则退出循环.

## do while循环

### 语法：
```
do {
	循环体;
} while (循环条件);
```



## break和continue

break：打破循环，终止循环的执行。

continue：停止本次循环，下一轮的循环还需要继续执行。


## for循环和while循环的区别
    一般在知道循环次数的时候会采用for循环
    在不确定循环次数的时候采用while会更多一些



# 十二、 随机数

在当前环境中，可以向系统索要一个15位的随机数，范围是[0,32767]。

## srand:

    可以设置一个随机数种子，这个函数只有一个参数，无符号的整型来表示种子的值即可，通常会使用时间戳。
    时间戳：从1970年1月1日0时0分0秒开始到当前时间所经过的秒数

## rand:

    可以获取一个随机数，没有参数，只有一个返回值，即获取到的随机数。

包含在stdlib.h头文件中


## time:

    这个函数可以获取时间戳，包含在头文件time.h中，函数需要传递一个NULL作为参数。


具体示例：
```
	//1-10随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 10);
	}

	printf("\n");

	//10-20随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 11 + 10);
	}

	//如果要获取[m,n]随机数
	//要实现rand() % (m - n + 1) + m
```

# 十三、 数组

    由编译器在内存中申请一块连续的内存空间，其中每一个空间的元素类型都是相同的。

## 基本语法：
	数据类型 数组名[数组长度];
	
	声明静态数组，中括号里的数组长度必须是常量。

## 数组的下标：
数组的元素位置下标从0开始依次递增，

    获取第一个元素为arr[0]
    获取第4个元素为arr[3]



## 数组初始化的方式
### 完全初始化：
```
int arr[5] = {10,20,30,40,50};
int arr2[] = {1,2,3,4};//完全初始化时可以省略数组长度
```

### 不完全初始化
```
int arr[4] = {10, 20, 30} //不完全初始化，缺少的元素默认为0
```
## 修改数组元素
```
arr[2] = 30;//指定位置赋值
```

# 十四、 排序算法 和 查找算法
##    选择排序
        原理：不断的找极值，将极值放到数组头部，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。

代码
```
for (int i = 0; i < n - 1; i++) {//进行n-1趟排序
		int min = a[i];
		int m_index = i;
		int temp = 0;
		for (int j = i + 1; j < n; j++) {
			if (a[j] < min) {//查找极小值位置
				min = a[j];
				m_index = j;
			}
		}
		temp = a[i];//临时变量存储当前位置值
		a[i] = min;当前位置值和最小值进行交换
		a[m_index] = temp;
	}
```
##    冒泡排序
		 原理：每一趟循环会将极值放到数组头部，剩下元素整体顺序不变，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。
		 冒泡排序可以优化，因为可能某一趟后已经排序完成，就不需要继续排序，这时可以添加一个标志，以此来判断是否进行了交换，如果没有，可以提前结束循环

代码：
```
	//未优化版本
	int temp;
	for (int i = 0; i < n - 1; i++) {//n个数只进行n-1趟排序
		for (int j = 0; j < n - 1 - i; j++) {//冒泡排序每趟能至少确定1个数的最终位置，因此后面排序用的数的数量减少
			if (a[j] > a[j + 1]) {升序排序
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
			}
		}
	}
	printf("\n");
	for (int i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}




	//优化版本
	int temp;
	int i;
	for (i = 0; i < n - 1; i++) {
		int exchange = 0;//增添交换标志，如果不是完全有序，必定会交换，此时exchange=1
		for (int j = 0; j < n - 1 - i; j++) {
			if (a[j] < a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				exchange = 1;
			}
		}
		if (!exchange) {//exchange=0说明这一趟没有进行交换，也即排好序了，就不需要在进行下一轮排序了。
			break;
		}
	}

```


##    插入排序
		  原理：将数组中的元素不断的插入到一个有序的数组中，当所有的数据都插入完毕的时候，数组已然有序。

代码：
```
	int i, j;
	for (i = 1; i < n; i++) {
		int temp = a[i];//存储当前值，来和前面的进行比较，然后插入
		//只有
		for (j = i; j > 0 && temp < a[j - 1]; j--) {
			a[j] = a[j - 1];
		}
		a[j] = temp;//插入
	}
```

## 二分法查找
###  原理
它是分治算法的一种应用，主要是在有序数组中查找某个元素的位置（下标）

其做法是准备三个下标，一个start代表数组第一个元素的下标，end代表最后一个元素的下标，

    让mid指向两者的中间的位置，然后让mid所指向的值和所需要查找的元素进行对比，
    如果mid的值比要查找的find值大，将m-1赋值给end，start不需要改变，直接排除后面一半的数据
    如果mid的值比要查找的find值小，将m+1赋值给start，end不需要改变，直接排除前面一半的数据
    如果mid对应的值是find的值，就说明找到了
    如果start的值比end的值还要大，就说明没找到元素

### 代码：
```
	int n, target;
	scanf("%d%d", &n, &target);
	int* a = (int*)malloc(sizeof(int) * n);
	for (int i = 0; i < n; i++) {
		scanf("%d",a + i);
	}
	int low = 0, high = n - 1;
	int flag = 0;
	int result = 0;
	while (low <= high) {
		int mid = low + (high - low) / 2;
		if (a[mid] > target) {
			high = mid - 1;
		}
		else if (a[mid] < target) {
			low = mid + 1;
		} 
		else {
			flag = 1;
			result = mid;
			break;
		}
	}
	if (flag) {
		printf("%d", result);
	} else{
		printf("未查找到数据");
	}
	free(a);
	a = NULL;
```

# 十五、 函数
## 介绍
面向过程的语言中最基础的单位就是函数，函数是一个代码块，拥有特定的输入接口，用于实现一个功能。

## 函数的定义和使用
    函数定义：函数类型 函数名(形参){函数体;}
    函数调用：函数名(实参);
    注意点：函数在被调用的时候，会在函数体内生成一个函数的栈帧，当函数执行完毕之后，栈帧就会被销毁，所以函数中的变量都是临时变量。


## 实参和形参
    形参：形式参数，在函数定义的时候括号中的参数
    实参：实际参数，在函数调用的时候括号中的参数


## 函数类型和返回值
    函数可以有返回值也可以没有返回值。
    函数的类型就是函数返回值的类型，可以是任意类型
    函数的返回值由return语句来给出
    如果函数没有返回值，函数的类型就是void类型，没有返回值也可以写return语句，后面直接跟分号
    return还有一个重要作用是终止函数



## 函数的递归
	递归需要满足的条件
	1、函数要自己调用自己
	2、必须要有终止条件，否则会变成死递归，造成栈溢出
### 代码演示

使用递归打印1~10
```
void Print(int num) {
	if (num > 0) {
		Print(num - 1);
		printf("%d\n", num);

	}
	return;
}
```
使用递归实现阶乘计算
```
int fun3(int num) {
	if (num > 1) {
		return  fun3(num - 1) * num;
	}
	else {
		return 1;
	}
}
```







<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>

# 第二周

<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>







# 十六、 指针 

## 概念
    在内存空间中每一个字节都有一个对应的编码，这个编码就是这个字节的地址，也叫做指针
    如果想要保存一个地址，应该使用用指针变量
    变量的地址：不同的类型变量应该在内存中占用不同大小的空间，比如int类型变量，占用4个字节，首地址就是变量的地址。

## 指针变量的定义
    数据类型* 指针变量名;
    注意点：指针变量的类型应该和它保存的地址对应的数据类型相同

## 运算符
    &：取址运算符，获取一个变量的地址
    *：解引用运算符，可以通过地址来获取其对应的内存中的值

## 多级指针

    int* p  //一级指针
    int** p  //二级指针
    int*** p  //三级指针

**注意** ：二级指针保存的是一级指针的地址，三级指针保存的是二级指针的地址

## 指针的大小

    指针大小和指针类型无关，和操作系统相关，如果是64位操作系统下的指针，占用8个字节，32位的占用4个字节

## 指针的算术运算

    指针运算，就是让当前地址进行前移或者后移操作，比如int* p指针，p+1就代表向后移动4个字节，double* p1, p1 + 1相当于向后移动8个字节，指针移动的单位和指针的类型相关。

## 常量指针和指针常量

### 常量指针

    只能改变指针的指向，不能改变指向的地址中的值  
    语法：const 类型* 指针名
    声明时可以不给初值

```
    示例：
	//可以改变指向，但不能改变值
	int a = 100, b = 200;
	const int* ptr = &a;//常量指针
	ptr = &b;
	printf("%d", *ptr);

```


### 指针常量

    不能改变指针的指向，可以改变指向的地址中的值
    语法：类型* const 指针名
    声明时必须给初值。

```
    示例：
	//可以改变值，但不能改变指向
	int* const p1 = &a;//指针常量
	*p1 = 300;
	printf("%d\t%d", *p1, a);
```

### 区分

    常量指针本质是指针，const修饰的是int*，说明整体的值不可改变，但是指针指向（即存入的地址）可以改变；
    
    指针常量本质是常量，const修饰的是指针本身，说明指针指向（即存入的地址）不可改变，而地址对应的值可以改变

## 空指针和野指针

###    空指针

        NULL代表空指针，就是值为0的指针。有些时候指针声明时候并不知道应该保存哪个地址，这个时候就可以将指针置为NULL。

###   野指针

        指向了不能合法访问的空间的指针就是野指针。

####   常见的场景

        没有初始化的指针
        函数返回了局部变量的指针
        数组越界的指针
        free后的指针


# 十七、动态分配内存

##     堆空间：

        由用户手动分配释放的空间，堆空间中所有的内容都是通过指针来访问的。

##    void*类型

        void*是C语言中的万用指针类型，经常用于指针类型的中转，可以隐式转化为其他类型的指针，也可以由其他类型的指针隐式转化来。
        隐式转化是有风险的，比如使用void*可以修改一个指针的指向，比如先指向double*，再隐式转化为int*，这种情况是不合适的，所以在C++中直接限制void*的使用，需要进行强转，才能转化为其他类型的指针。

##     动态内存分配的函数

###        malloc

            头文件：stdlib.h
            函数声明：void* malloc(size_t size);  // 从堆上分配一块size字节大小的空间，返回其首地址

###         free

            函数声明：void free(void* ptr); // 释放ptr指向的堆空间中的动态空间
            free只能释放动态内存分配的地址指针，不能释放普通变量的指针

###        calloc

            函数声明 void* calloc(size_t num, size_t size) // 从堆上分配一个大小为num * size个字节的空间，初始化成0之后返回首地址

### realloc

    函数声明：void* realloc(void* ptr, size_t size); // 可以重新给一个指针分配新的空间。
    函数的操作步骤
        1、首先会在函数内部申请一个新的空间，大小就是参数2
        2、将参数1中的内容全部拷贝到函数中开辟的新空间中
        3、最后会将参数1中的空间给释放掉
        4、将申请的新空间的地址以返回值的形式返回给函数


### 指针的应用：

#### 一、动态内存管理（你最熟悉的场景）

##### 应用场景

    创建运行时才能确定大小的内存（比如你的动态数组），而非编译时固定大小的数组。

##### 核心价值

    突破 “静态数组大小固定” 的限制，按需分配 / 释放内存，避免内存浪费。

##### 示例（你的代码核心逻辑）

```
// 1. 动态分配内存（malloc）
int* arr = (int*)malloc(n * sizeof(int)); 

// 2. 调整内存大小（realloc）
int* new_arr = (int*)realloc(arr, sizeof(int) * (n + 1));

// 3. 释放内存（free）+ 置空指针（避免野指针）
free(*arr);
*arr = NULL;
```

#### 二、修改函数外部变量（你问的实参修改场景）

##### 应用场景

    让函数直接修改主调函数中的变量（普通变量、指针变量、数组大小等）。

##### 核心价值

    突破 C 语言 “值传递” 的限制，实现函数对外部变量的 “写操作”。

##### 示例

```
// 1. 修改普通变量
void changeInt(int* num) { *num = 100; }

// 2. 修改数组大小（你的insertNum）
void updateSize(int* size) { (*size)++; }

// 3. 修改指针变量本身（你的freeArr）
void freeAndNull(int** p) { free(*p); *p = NULL; }
```

#### 三、操作数组（数组的本质是指针）

##### 应用场景

    遍历、修改数组元素，实现数组的灵活操作（比如你的 printArr、assignArr）。

##### 核心价值

    数组名本质是 “指向首元素的常量指针”，指针运算比数组下标更灵活、效率更高。

##### 示例

```
// 数组下标方式：arr[i]
// 指针方式：*(arr + i)（等价于arr[i]，更底层）
void printArray(int* arr, int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", *(arr + i)); // 指针遍历数组
    }
}
```

#### 四、实现函数返回多个值

##### 应用场景

    C 语言函数默认只能返回一个值，用指针可以 “返回” 多个结果。

##### 核心价值

    避免用全局变量传递结果，提升代码模块化。

##### 示例

```
// 一个函数同时返回两数的和与积
void calc(int a, int b, int* sum, int* product) {
    *sum = a + b;       // 用指针返回和
    *product = a * b;   // 用指针返回积
}

int main() {
    int s, p;
    calc(3, 5, &s, &p); // 传入接收结果的变量地址
    printf("和：%d，积：%d\n", s, p); // 输出：和：8，积：15
    return 0;
}
```

#### 五、实现链表 / 树等复杂数据结构

##### 应用场景

    构建非连续存储的动态数据结构（链表、二叉树、图等）。

##### 核心价值

    这类结构需要通过指针 “链接” 不同的节点，无法用普通变量实现。

##### 示例（简单链表节点）

```
// 链表节点定义：用指针指向下一个节点
typedef struct Node {
    int data;
    struct Node* next; // 指针链接下一个节点
} Node;

// 创建新节点
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
```

### 内存泄漏：

    程序中动态分配的内存（通过malloc/calloc/realloc申请），
    在不再使用后，既没有被释放（free），也丢失了指向这块内存的指针 → 这块内存永远无法被程序回收和复用，直到程序退出，系统才会回收。

# 十八、二维数组

    作用：将一些可以当做表格处理的数据，更加适合存放在二维数组中处理。
    
    定义方式：数据类型 数组名[行数][列数];
    
        二维数组可以被认为是一维数组嵌套一维数组的形式，{{1,2,3},{4,5,6}}


# 十九、指针数组

    概念：数组元素都是指针的数组就是指针数组。
    
    定义方式：类型名* 数组名[数组长度];

# 二十、数组指针

## 概念：

指向整个数组的指针就是数组指针，本质是一个指针

## 定义方式：

类型名(*数组指针名)[数组指针长度];

# 二十一、宏定义的传参

##     概念

        宏定义是将代码中和宏名相同的内容，替换为宏名后的值

![1](D:/c_study/day8/note/1.png)

# 二十二、外部声明extern

    extern关键字可以扩展函数或者全局变量（函数外部的变量）的作用域扩展到别的文件中。
    A.c

![2](D:/c_study/day8/note/2.png)
    B.c
![3](D:/c_study/day8/note/3.png)

# 二十三、函数指针

    概念：保存函数地址的指针变量，可以叫做函数指针变量。
    定义语法：函数类型 (*函数指针名)(形参类型表);

****

# 二十四、回调函数：

## callback

就是回调函数，函数指针经常用于函数的参数列表中，表示向函数传入一个功能。（而不是简单的在一个函数中调用另外一个函数）

## qsort

- 是C标准库中提供一个快速排序的函数，包含在头文件*stdlib*

- 函数原型：

  ```c
  void qsort(void* Base, size_t NumOfElements, size_t SizeOfElements), int(*comfunc)(const void* , const void*));
  ```

  

  - Base：数组本身的地址

  - NumOfElements：数组中元素的个数

  - SizeOfElements：数组中每个元素的大小

  - comfunc：比较规则，其中第一个参数如果比第二个参数小，就返回负数，如果比第二个大就返回正数，相等返回0(默认升序)

    **返回值 > 0**：`qsort` 会认为 `arg1` 指向的元素 **大于** `arg2` 指向的元素，需要将 `arg1` 排在 `arg2` 的**后面**。

    **返回值 < 0**：`qsort` 会认为 `arg1` 指向的元素 **小于** `arg2` 指向的元素，需要将 `arg1` 排在 `arg2` 的**前面**。

    **返回值 = 0**：`qsort` 会认为 `arg1` 指向的元素 **等于** `arg2` 指向的元素，两者顺序保持不变（相对稳定，`qsort` 本身是不稳定排序，但等值元素顺序不主动调整）。

# 二十五、字符数组和字符串

## 输入输出缓冲区

## 输出缓冲区

- 就将临时存放的所有的待显示数据，直接输出到屏幕中

- 清除缓冲区的场景：

  - 1、当一个输出语句结束的

  - 2、输出缓冲区溢出（大小1k左右）

  - 3、程序结束

## 输入缓冲区

- 当用户敲下回车的时候，将临时数据放入输入缓冲区，然后由输入缓冲区按照各种类型规则将数据放入指定的变量中，已经成功取走的数据就清理掉，如果数据没有被取走，就会一直存放在缓冲区中。

注意点：

由于输入缓冲区的规则是敲下回车的那一刻，所以输入缓冲区的最后一个字符一定是回车（换行）。

### 输入缓存区的读取规则：

- 1、%d/%f/%lf
  - 跳过所有的空白符（空格、回车、\t等等），遇到负号或者数字的时候才开始进行转化，遇到非数字的字符就停止，如果%f或者%lf会允许出现一个小数点，如果在转化的过程中没有遇到数字字符，就表示转化失败。

- 2、%c和getchar()
  - 无条件的读取缓存区中的一个字符，无论字符是什么都要。

- 3、%s
  - 跳过所有的空白符，遇到可见字符才开始接受，遇到空格或者回车就停止。

## 字符数组

### 概念

- 在程序中经常需要存储各种字符类型文本数据，比如：人名、住址等等，需要字符数组或者字符串来完成存储。

- ![image](D:\c_study\day9\note\1.png)

## 字符串系列常用函数

### 数字处理函数

##### atoi

- 在头文件 stdlib.h中

- 函数声明：int atoi(const char* str);

- 作用：将一个数字字符构成的字符串转化为int类型的整数返回

### 同类型的函数

- long类型     **atol(const char* str);**

- double类型   **atof(const char* str);**

### memset

- 函数原型：void* memset(const void* ptr, char val, size_t size);

- 作用：将内存中的一段空间全部赋给某个值，将ptr指向的位置之后的size个字节内容全部写成val

### memcpy

- 函数原型：void* memcpy(void* dst, const void* src, size_t size);

- 作用：将src所指向的位置后的size个字节复制到dst所指向的位置

### strlen

- 函数原型：size_t strlen(const char* str);

- 作用：计算str字符串的长度，不包括结束标识，只计算有效字符数

### strcpy和strncpy

- strcpy

  - 函数原型：char* strcpy(char* dst, const char* src);

  - 作用：将src指向字符串复制给dst，然后返回dst

- strncpy

  - 函数原型：char* strncpy(char* dst, const char* src, int n);

  - 将src指向字符串的前n个字符复制给dst，然后返回dst

### strcat和strncat

- strcat

  - 函数原型：char* strcat(char* dst, const char* src);

  - 作用：将src拷贝到dst的结尾处，拼接dst和src

- strncat

  - 函数原型：char* strcat(char* dst, const char* src, int n);

  - 作用：将src的前n个字符拷贝到dst的结尾处

### strcmp和strncmp

- strcmp

  - 函数原型：int strcmp(const char* s1, const char* s2);

  - 作用：比较两个字符串的大小， 如果前面比后面大，就返回正数，如果前面比后面小就返回负数，如果一样大就返回0

  - 比较原则：逐个比较两个字符串的字符，直到遇到第一个不相同的字符，比较其对应的ASCII码值，哪个字符的ASCII码值更大，那么就直接决定哪个字符串大，后面的字符就不再比较了。如果比较到了两个字符串的结尾值都一样，就说明两个字符串相等

- strncmp

  - 函数原型：int strcmp(const char* s1, const char* s2, int n);

  - 比较两个字符串的前n个字符的大小

### 查找类函数

- strchr

  - 函数原型：char* strchr(const char* src, char f);

  - 作用：在字符串src中查找字符f第一次出现的位置

- strrchr

  - 函数原型：char* strrchr(const char* src, char f);

  - 作用：在字符串src中查找字符f最后一次出现的位置

- strstr

  - 函数原型：char* strstr(const char* src, const char* f);

  - 作用：在字符串src中查找字符串f第一次出现的位置

- strpbrk

  - 函数原型：char* strpbrk(const char* src, const char* f);

  - 作用：在字符串src中找字符串f中任意一个字符第一次出现的位置

- 以上四个函数，如果找到元素就返回相应的地址，否则就返回NULL（空）

### strtok

- 函数原型：char* strtok(const char* src, const char* delim);

- 作用：根据分割字符集delim的字符，分割字符串src，只需要传递一次src就可以了，后面传空，就可以不断的去分割一个字符串，直到字符串不能再分割就返回空。

### 判断字符的函数

- isalpha：判断是否是字母，是就返回正数，否则返回0

- isdigit：判断是否是数字

- isalnum：判断是否是数字或字母

- isupper：判断是否是大写

- islower：盘算是否是小写

# 二十六、 结构体

## 概念

- 结构体就是将基本的数据类型进行封装，到一个统一的自定义类型中的语法。

- 比如：学生信息有姓名、年龄、分数等等，由于数据类型不同，无法用一个数组来保存，结构体就可以完成学生信息的定义和存储。

## 结构体定义方式

- struct 结构体名 {数据类型1 成员名1; 数据类型2 成员名2;.....};

- 结构体变量的定义

  - struct 结构体名 结构变量名;

  - 如果需要用结构变量名获取其中的成员值，就需要用.运算符来完成

## 结构体数组

### 定义方式

- 结构体类型名 结构体数组名[数组长度];

- 结构体指针
  - 定义方式
    - 结构体类型名* 结构体指针名

### 时间函数

- 包含在头文件time.h

- 获取时间戳

  - time_t time(time_t ptm);

  - 可以获取从1970年1月1日到当前时间秒数

### 将时间戳直接转化为字符串

- char* ctime(time_t *ptm);

- 可以根据时间戳返回一个固定格式的日期字符串

### 结构体内存对齐问题

- 结构体对齐原则

  - 1、结构体的第一个成员在结构体的开始的地址处

  - 2、其他成员要对齐到某个数字的整数倍的地址处，（这个数字叫做对齐数）
    - 对齐数：编译器默认的对齐数和该成员的较小值（vs中默认的对齐数是8，Linux中默认的对齐数是4）

  - 3、结构体占用总大小是结构体中最大对齐数的整数倍

  - 4、如果结构体出现了嵌套，嵌套的结构体首地址应该按照其成员中最大对齐数的整数倍地址处存放

- 例1：
  - 例1：
  
    - 代码
  
      ![img](D:\c_study\day11\note\结构体.png)
  
      ![img](D:\c_study\day11\note\结构体存储.png)
  
  - 例2：
  
    - 代码![img](D:\c_study\day11\note\结构体例2.png)![img](D:\c_study\day11\note\结构体存储例2.png)
  
  - 例3
  
    - 代码
  
      ![img](D:\c_study\day11\note\结构体例3.png)![img](D:\c_study\day11\note\结构体存储例3.png)
  
  - 例4:
  
    - 代码
    - ![img](D:\c_study\day11\note\结构体例4.png)![img](D:\c_study\day11\note\结构体存储例4.png)
  
  - 例5：
  
    - 代码
  
      ![img](D:\c_study\day11\note\结构体例5.png)![img](D:\c_study\day11\note\结构体存储例5.png)
  
  ## 位段（位域）
  
  - C语言允许多个结构体成员来使用几位存储数据![img](D:\c_study\day11\note\位域.png)

# 二十七、枚举类型

- 概念：用标识符表示整型常量的集合，用关键字enum来定义

- 枚举类型语法：enum 枚举类型名 {枚举元素1, 枚举元素2...};

- 注意点：

  - 枚举元素如果没有给初始值，默认第一个枚举元素代表0，后面的枚举元素依次加1,

  - 枚举元素不能重名

# 二十八、内存空间区块划分

## 栈区

- 由系统自动分配和释放空间，随着函数的开始而开始，随着函数的结束而结束。

- 堆区
  - 由用户手动分配释放的空间，随着用户的创建而存在，随着用户的释放而结束。

## 静态区

- 主要存放的是全局资源，它们不会被释放，随着程序的开始而开始，随着程序的结束而结束。

- 常量区
  - 各种常量资源，除了字符串常量以外，所有的常量都保存在这里。因为字符串常量会存放在专属的字符串常量区

## 代码区

- 代码存放的区域，执行的时候直接从这里取出。

# 二十九、变量的生命周期

## 局部变量

- 在函数内部定义的变量，就是局部变量

## 全局变量

- 在函数外部定义的变量，就是全局变量

## 静态变量

- 静态变量：静态存储的变量在程序运行期间，会分配固定的存储空间并且一直存在。

- 动态变量：函数中声明的普通变量，在函数被调用的时候会分配空间存在，离开时被释放，当再一次调用函数的时候，重新为其分配空间。

- 静态变量定义：static 数据类型 变量名;

# 三十、文件指针

## 概念

- 文件指针FILE* 类型本质上是一个结构体指针，这个指针由系统自动进行管理，我们只需要获取到进行操作即可。

## 文件操作函数

###  fopen

- FILE* fopen(const char* fname, const char* mod);

  - 以mod的方式打开一个名称为fname的文件，如果成功就返回相应的文件指针，如果失败就返回空。

  - fname
    - 主要填写的是文件的路径，有相对路径（从当前路径开始逐步跳转到指定路径）和绝对路径（从盘符开始逐步跳转到指定路径）之分

  - mod

    - r：以只读的形式打开文件。如果文件存在就代开，不存在打开失败

    - w：以只写的方式打开文件。 如果文件存在则覆盖，不存在就直接创建文件

    - a：以只写追加的方式打开文件。文件存在就打开并且将文件指针移动文件末尾，文件不存在就创建

  - 基于mod方式的可选项

    - +：原本只读/只写的方式变为可读可写

    - b：以二进制的方式打开文件

###  fclose

- 操作完文件之后需要对文件进行关闭，否则后期再打开文件的时候会出现问题，或者导致文件的修改结果无法保存。
  - int fclose(FILE* fp);

###  fputs

- int fputs(const char* buffer, FILE* fp);
  - 将buffer的内容打印到文件指针fp的位置。

###  fgets

- int fgets(char* buffer, size_t size, FILE* fp);

  - 将fp中的文件内容按行转移到buffer中，至多转移size个字节

  - 注意点：函数中保存最大的读取大小是size-1个字符，因为字符串以\0，为了保证字符串的完整性，给结束标识要留一个位置。

###  fprintf

- int fprintf(FILE* fp, const char* format,...);
  - 将原本要输出到屏幕中的内容打印到文件fp中

###  fgetc

- 获取单个字符

###  fput

- 将单个字符打印到文件中

###  fread

- 函数原型：size_t fread(void* buffer, size_t elesize, size_t n, FILE* fp);
  - 从文件中读取elesize*n个字节的内容放到buffer中

###  fwrite

- 函数原型：size_t fwrite(void* buffer, size_t elesize, size_t n, FILE* fp);
  - 将buffer中长度为elemsize*n个字节的内容以二进制的形式写入到文件中



### feof

- 函数原型：int feof(FILE* fp);
  - 用于判断文件是否已经到了末尾，如果文件已经达到末尾就返回1，否则返回0

### fseek

- 函数原型：int fseek(FILE* fp, size_t offset, int origin); 

  - 以origin为基准，使文件指针跳转offset个字节，如果为正数代表向后跳转，如果为负数，代表向前跳转

  - 跳转基准

    - SEEK_SET：以头部为基准跳转

    - SEEK_CUR：以当前位置为基准跳转

    - SEEK_END：以尾部位置为基准跳转

### ftell

- 函数原型：size_t ftell(FILE* fp);
  - 查询当前文件指针距离头文件的字节数





<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>

# 第三周：C++基础

<u>----------------------------------------------------------------------------------------------------------------------------------------------</u>







# 一、输入和输出

- 头文件：iostream：input ouput stream 代表输入输出流

- cout：C++的输出，cout紧跟左移运算符。例如：cout << 表达式1 << 表达式2 << ....;

- cin：C++的输入，cin紧跟右移运算符。例如：cin >> 变量1 >> 变量2....;

- endl：end of line，主要作用是换行。

# 二、new和delete

- 作用：分配动态空间

- 语法

  - 分配单个空间：new 类型名(初始值)

  - 分配连续空间：new 类型名[元素个数]

- delete释放空间

  - 删除的是单个内存：delete 指针名

  - 删除的是多个内存：delete[] 指针名

静态数组空间的生命周期会随着函数的结束而结束，所以不能从函数中返回数组

动态的空间不会随着函数结束而结束，必须手动销毁才能释放。

# 三、引用

引用概念：是已有变量或者表达式的一种别名机制，主要用于函数的形参和返回值。

作用：给变量起别名

语法：数据类型 &别名 = 原名;



# 四、内联函数

### 概念

- 对于一些规模较小并且会被频繁调用的函数可以定义为内联函数，以提高程序的执行效率，内联函数不是在调用的时候发生控制转移的，而是在编译的时候，直接将对应函数的函数体内嵌到每个函数的调用处，从而节省函数调用的资源开销，但是会增加编译后的程序空间。相当于用空间换时间。

### 图示

![img](D:\c_study\day12\note\1.png)

### 定义方式：

inline 函数类型 函数名(参数列表);

### 注意点：

- 并不是所有的函数都可以直接定义为内联函数，如果函数内部的结构稍复杂，那么就算定义了内联函数，程序也会将其当做普通函数来对待。

- 复杂场景：比如循环、分支等情况，即使定义了内联函数，也不会将其当做内联函数对待。

# 五、函数重载

### 概念

- C++允许定义多个同名函数，只要保证形参类型或者形参个数不同即可。

- 函数的返回值类型（函数的类型）不能作为重载依据的。

# 六、函数的默认参数

### 概念

- 定义函数的时候，可以预先为函数形参指定默认值，在函数调用的时候，如果给了实参，就使用实参的值，否则就采用默认值。

### 注意点：

- 默认形参的定义顺序必须是由右向左来完成，如果某一个形参有默认值，那么它右侧的所有形参必须都有默认值。
