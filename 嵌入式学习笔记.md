# 嵌入式学习 每周总结

# 第一周

# 一、 头文件
## #include <>的搜索顺序：
1. 系统标准头文件目录：

    1.编译器内置的标准库路径

    2.操作系统提供的系统头文件路径

2. 编译器指定的包含路径：

    1.通过 -I 选项添加的目录

    2.环境变量指定的路径

## #include " "的搜索顺序：
1. 当前文件所在目录

2. 当前编译单元所在目录

3. 编译器指定的包含路径（与 #include＜＞ 共享）

4. 系统标准头文件目录

一句话总结，<> 从系统库的默认路径中查找，存在就打开，否则失效，“” 从当前项目中找对应的头文件，若找不到就从系统库的默认路径中查找，如果还找不到就失效。

**记住这个简单的原则：系统及第三方库用 ＜＞，项目自己的文件用 ""**

# 二、 注释：
## 单行注释 ： // 
    添加快捷键：ctrl + k + c

    删除快捷键：ctrl + k + u

## 多行注释 ： /* */ 

# 三、 变量：
## 概念：
在内存空间中申请一片可以自己操作的空间，大小根据类型来定。

## 内存大小：
bit 、Byte ； 1B=8b ；KB,MB,GB,TB,PB,EB,ZB

## 命名规则：
        1. 只能有数字、字母、下划线组成。

        2. 一般以字母开头，下划线开头有特殊含义，不能由数字开头。

        3. 不能和关键字重名。

        4. 变量名要见名知意。

        5. 变量名过长可用下划线或驼峰式(首单词的字母都小写，后面的每一个新单词首字母大写)命名 。               

        下划线：student_age

        驼峰式：studentAge
# 四、常量：


1、 包括**整数常量**、**浮点常量**、**字符常量**等，不可被赋值运算符更改。

**字符常量**：使用单引号’，‘a’

**字符串常量**：使用双引号”，“asdf”

字符串字面量不能直接和字符字面量直接比较。

2、在 C 中，有两种简单的定义常量的方式：

    使用 #define 预处理器： #define 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。

    使用 const 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。
**注：const声明常量需要在一个语句中完成。**

![alt text](.\day2\note\569ee770273e429898b00aaad0b2f4cd.png)
![alt text](.\day2\note\2b04b3f16172420c922e634f12301b63.png)


## #define 与 const 区别
#define 与 const 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。通常情况下，建议使用 const 关键字来定义常量，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

#define 预处理指令和 const 关键字在定义常量时有一些区别：

**替换机制**：#define 是进行简单的文本替换，而 const 是声明一个具有类型的常量。#define 定义的常量在编译时会被直接替换为其对应的值，而 const 定义的常量在程序运行时会分配内存，并且具有类型信息。

**类型检查**：#define 不进行类型检查，因为它只是进行简单的文本替换。而 const 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。

**作用域**：#define 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 const 定义的常量具有块级作用域，只在其定义所在的作用域内有效。

**调试和符号表**：使用 #define 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 const 定义的常量会在符号表中有相应的条目，有助于调试和可读性。

## 浮点类型：
double和lfloat

float精确范围：7位有效数字

double精确范围：15~16位有效数字

# 五、 字符型：
ASCII码表：
![alt text](.\day2\note\55e44d264e2b4dd0b4bb1fdcb8b935ea.png)


## 不可见字符【0-32】、【127】：灰色部分
## 可见字符：
        数字字符【48-57】

        大写字母【65-90】

        小写字母【97-122】

        注：大小写字母差值为32，大写字母数值较小。

## 转义字符：
转义字符可以将一些具有特殊含义的字符转化为普通字符使用，或者也可以将一些普通字符转化为具有特殊含义的字符来使用
    \n：换行符
    \t：水平制表符
    \\：输出反斜杠
    \“：输出双引号


# 六、 输入输出：
## 单个字符输入输出：
getchar():获取一个字符，包括空格、换行。

putchar():输出一个字符到控制台。

常见例子：大写字母换成小写字母：
```
    int c;
    while ((c = getchar()) != '\n'){
        if (c >= 65 && c <= 90) {
            c = c + 32;
        }
        if (c != '\n') {
            printf("%c", c);
        }
    }
```
## 标准输入输出：
scanf():  scanf(字符串,变量地址); //字符串中一般要写接受的数据的类型，比如%d 有符号整型

printf():

## printf 参数
在printf中，有一个双引号引起来的常量字符串，里面用%做占位符，每个占位符都要在后面加上对应的参数，根据不同的类型，将数据解读成不同的样式。

### 进制：
        %u：无符号十进制

        %o：无符号八进制

        %x：无符号十六进制

        %d：有符号十进制

### 类型：
        %i：整型

        %f：浮点型，控制的是：保留【小数点后 n 位】，默认值是 6 位；对最后一位遵循 四舍五入 规则；只会以「普通小数格式」输出，永远不会触发科学计数法，哪怕是极大数 / 极小数。

        %c：字符型

        %s：字符串型

        %p：指针类型

### 科学计数法：
       %g 控制的是：保留【n 位有效数字】，默认值是 6 位。

        自动二选一格式：阈值为 数值数值在此区间内 → 用「普通小数格式」输出；

                                     数值 < 10−4 或 数值 > 106 → 用「科学计数法格式」输出；

        自动精简去 0：去掉小数点后无意义的末尾 0，这是%g最实用的特性；

        自动去小数点：如果去 0 后小数点后没有数字，直接去掉小数点本身；

        四舍五入规则：对最后一位有效数字正常四舍五入。
        
# 七、 位运算
##    |:按位或
        两个数字的二进制对应的位置只要有1结果就是1，否则为0（有1则1）
示例：
```
    //练习1：大写转小写
    char ch1;
    while ((ch1 = getchar()) != '\n') {
        ch1 |= 0x20;
        printf("%c", ch1);
    }
```   
##   &:按位与
        两个数字的二进制对应的位置只要有0，结果就为0，否则为1（有0则0）

示例：
```
    //练习2：小写转大写
    char ch2;
    while ((ch2 = getchar()) != '\n') {
        ch2 &= ~0x20;
        printf("%c", ch2);
    }
```
##    ^:按位异或
        两个数字的二进制对应的位置数字如果相同，结果就为0，如果不同结果为1（同0异1）
示例：
```
    //练习3:大写转小写，小写转大写
    char ch3;
    while ((ch3 = getchar()) != '\n') {
        ch3 ^= 0x20;
        printf("%c", ch3);
    }
```
##    << 按位左移
        将一个数字的对应二进制的所有的位，向左侧移动一位，高位溢出，低位补零
        注意点：
            1、溢出的数字直接消失，不会再被找回来（高位溢出之后，不能再用右移取回）
            2、左移相当于将当前的数字 乘以 2^n，  比如说数字3，左移4位，就相当于 3 * 2^4


##   \>> 按位右移
        将一个数字的对应二进制的所有位向右移动一位，低位溢出，高位补零
        右移相当于将当前的数字除以2^n，比如说数字10，右移2位，相当于10 / 2^2

##    ~按位取反
        将数字对应的二进制的各个位，进行取反，原来是0就换成1，原来是1就换成0
        比如：0000 1010(10)  取反 1111 0101（245）


##  原码、反码、补码

    原码：
    最高位是符号位，0表示正数，1表示负数

    反码：
    最高位是符号位，0表示正数，1表示负数，正数的反码等于它本身，负数的反码除了符号位以外，其余各位取反

    补码：
    最高位是符号位，0表示正数，1表示负数，正数的补码等于它本身，负数的补码是反码+1


    原码转补码：正数不变，负数除了符号位以外，其余各位取反+1
    补码转原码：正数不变，负数除了符号位以外，其余各位取反+1
    注：即数值位从右往左数第一个‘1’开始的左边全部取反。

按位运算符可以和赋值运算符放一起：
    |=、&=、<<=、>>=、^=、=

## 运算符优先级
![alt text](.\day3\note\1.png)


# 八、左值右值

##    左值
        可以出现在赋值运算符左边的，也可以出现在赋值运算符的右边，标识了一个可以存储结果的地点（内存空间）
        程序在编译的时候，编译器会为每一个变量都分配一个地址，所以变量一般都是左值，地址在编译的时候是可知的。

##    右值
        出现在赋值运算符右边的，它必须有一个特定的值。
        在变量中存储的那个值，一般都是右值，只有在程序运行的时候才可知。
        右值是一个字面量或者一个数字或者一个常量，它在内存中并没有一个具体的地址

大多数表达式都具有右值的属性，因为每个变量所标识的空间地址都会存储一个具体的值，只要表达式不出错，那么它就会获取到一个特定的值。


# 九、类型转换
## 隐式类型转换
    从低等级到高等级的类型转换就是隐式类型转换，例如：int -> unsigned int、 long->unsigned long、float->double。
## 强制类型转换
    (类型说明符)(表达式)：一般后面是一个表达式的时候，需要加括号先计算表达式结果，再强转
    (类型说明符)变量/值：如果后面是一个变量或者一个具体的数字，可以加也可以不加，没有影响


# 十、 选择语句
## if语句
    语法:
```
if (条件表达式) {
        执行语句;
} else if (条件表达式) {
    执行语句;
} ..... //中间以及最后的语句可有可无
 else {
    执行语句;
}
```

总结：
    if语句会自上而下进行判断，如果有已经成立的条件，不会继续向下判断了
    所有的分支都不成立的时候，去else
    else if  或者 else 不是必须的，依据实际的场景看是否需要


## switch语句
主要是对一个输入数据进行判等的操作。
语法：
```
switch(整型/枚举){
    case 常量1：
         执行语句；
         break；
    case 常量2：
         执行语句；
         break；
    case 常量3：
         执行语句；
         break；
    case 常量4：
         执行语句；
         break；
    ......
    default:
         执行语句；
}
```

执行思路：将switch括号中的值和每一个case后的常量值进行对比，如果都匹配的就执行相应的语句，否则就执行default

注意：
    每一个case后面都应该有一个break，为了防止穿透执行，如果没有break，当满足了某一个case之后，会持续向下执行case语句，直到遇到break或者整个switch语句结束为止。
    switch中的所有case后的常量值都不可以重复。

## if语句和switch语句的使用场景
    if语句一般用于一个范围判断
    switch语句一般用于一个确定的值进行相等判断，主要用于代码的整理，更加清除的梳理代码结构

# 十一、 循环语句

## for循环

### 语法：
```
for (循环变量;循环条件;操作表达式){
    循环体;
}
```

### 执行思路：
    1、先执行循环变量
    2、判断循环条件
    3、执行循环体
    4、执行操作表达式
    5、判断循环条件（满足继续循环，不满足退出循环）

### 示例：
```
	//练习1：求1-20偶数和
	int sum = 0;
	for (int i = 1; i <= 20; i++) {
		if (i % 2 == 0)
		{
			sum += i;
		}
	}
	printf("%d", sum);

	//优化版本
	for (int i = 2; i <= 20; i += 2) {//这里也可通过乘2实现
		sum += i;
	}
	printf("%d", sum);

	//练习2：10阶乘
	long int result = 1;//虽然不会溢出，以防万一，开大点
	for (int i = 1; i <= 10; i++) {
		result *= i;
	}
	printf("%ld", result);


	//练习3：1-10阶乘和
	long int result = 1;
	long int sum = 0;
	for (int i = 1; i <= 10; i++) {
		result *= i;
		sum += result;
	}
	printf("%d", sum);

	//练习4：
	int m = 0, n = 0;
	scanf("%d%d", &m, &n);
	int sum = 0;
	int temp = 0;
	for (int i = 0; i < m; i++) {
		temp = temp * 10 + n;
		//printf("%d ", temp);
		sum += temp;
	}
	printf("%d", sum);

	//练习5：求数字各个位之和
	int num;
	scanf("%d", &num);
	int sum = 0;
	//for (; num != 0;) {
	//	sum += num % 10;
	//	num /= 10;
	//}
	for (int i = num; i != 0; i /= 10) {
		sum += i % 10;
	}
	printf("%d", sum);
```

## while循环

### 语法：
```
while （循环条件）{
    循环体;
}
```

### 执行思路：
    当循环条件为真的时候就执行循环体，否则退出循环.

## do while循环

### 语法：
```
do {
	循环体;
} while (循环条件);
```



## break和continue

break：打破循环，终止循环的执行。

continue：停止本次循环，下一轮的循环还需要继续执行。


## for循环和while循环的区别
    一般在知道循环次数的时候会采用for循环
    在不确定循环次数的时候采用while会更多一些



# 十二、 随机数

在当前环境中，可以向系统索要一个15位的随机数，范围是[0,32767]。

## srand:

    可以设置一个随机数种子，这个函数只有一个参数，无符号的整型来表示种子的值即可，通常会使用时间戳。
    时间戳：从1970年1月1日0时0分0秒开始到当前时间所经过的秒数

## rand:
       
    可以获取一个随机数，没有参数，只有一个返回值，即获取到的随机数。

包含在stdlib.h头文件中


## time:

    这个函数可以获取时间戳，包含在头文件time.h中，函数需要传递一个NULL作为参数。


具体示例：
```
	//1-10随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 10);
	}

	printf("\n");

	//10-20随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 11 + 10);
	}

	//如果要获取[m,n]随机数
	//要实现rand() % (m - n + 1) + m
```

# 十三、 数组

    由编译器在内存中申请一块连续的内存空间，其中每一个空间的元素类型都是相同的。

## 基本语法：
	数据类型 数组名[数组长度];

	声明静态数组，中括号里的数组长度必须是常量。

## 数组的下标：
数组的元素位置下标从0开始依次递增，

    获取第一个元素为arr[0]
    获取第4个元素为arr[3]



## 数组初始化的方式
### 完全初始化：
```
int arr[5] = {10,20,30,40,50};
int arr2[] = {1,2,3,4};//完全初始化时可以省略数组长度
```

### 不完全初始化
```
int arr[4] = {10, 20, 30} //不完全初始化，缺少的元素默认为0
```
## 修改数组元素
```
arr[2] = 30;//指定位置赋值
```

# 十四、 排序算法 和 查找算法
##    选择排序
        原理：不断的找极值，将极值放到数组头部，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。
        
代码
```
for (int i = 0; i < n - 1; i++) {//进行n-1趟排序
		int min = a[i];
		int m_index = i;
		int temp = 0;
		for (int j = i + 1; j < n; j++) {
			if (a[j] < min) {//查找极小值位置
				min = a[j];
				m_index = j;
			}
		}
		temp = a[i];//临时变量存储当前位置值
		a[i] = min;当前位置值和最小值进行交换
		a[m_index] = temp;
	}
```
##    冒泡排序
		 原理：每一趟循环会将极值放到数组头部，剩下元素整体顺序不变，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。
		 冒泡排序可以优化，因为可能某一趟后已经排序完成，就不需要继续排序，这时可以添加一个标志，以此来判断是否进行了交换，如果没有，可以提前结束循环
		 
代码：
```
	//未优化版本
	int temp;
	for (int i = 0; i < n - 1; i++) {//n个数只进行n-1趟排序
		for (int j = 0; j < n - 1 - i; j++) {//冒泡排序每趟能至少确定1个数的最终位置，因此后面排序用的数的数量减少
			if (a[j] > a[j + 1]) {升序排序
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
			}
		}
	}
	printf("\n");
	for (int i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}




	//优化版本
	int temp;
	int i;
	for (i = 0; i < n - 1; i++) {
		int exchange = 0;//增添交换标志，如果不是完全有序，必定会交换，此时exchange=1
		for (int j = 0; j < n - 1 - i; j++) {
			if (a[j] < a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				exchange = 1;
			}
		}
		if (!exchange) {//exchange=0说明这一趟没有进行交换，也即排好序了，就不需要在进行下一轮排序了。
			break;
		}
	}

```


##    插入排序
		  原理：将数组中的元素不断的插入到一个有序的数组中，当所有的数据都插入完毕的时候，数组已然有序。
		  
代码：
```
	int i, j;
	for (i = 1; i < n; i++) {
		int temp = a[i];//存储当前值，来和前面的进行比较，然后插入
		//只有
		for (j = i; j > 0 && temp < a[j - 1]; j--) {
			a[j] = a[j - 1];
		}
		a[j] = temp;//插入
	}
```

## 二分法查找
###  原理
它是分治算法的一种应用，主要是在有序数组中查找某个元素的位置（下标）

其做法是准备三个下标，一个start代表数组第一个元素的下标，end代表最后一个元素的下标，

    让mid指向两者的中间的位置，然后让mid所指向的值和所需要查找的元素进行对比，
    如果mid的值比要查找的find值大，将m-1赋值给end，start不需要改变，直接排除后面一半的数据
    如果mid的值比要查找的find值小，将m+1赋值给start，end不需要改变，直接排除前面一半的数据
    如果mid对应的值是find的值，就说明找到了
    如果start的值比end的值还要大，就说明没找到元素

### 代码：
```
	int n, target;
	scanf("%d%d", &n, &target);
	int* a = (int*)malloc(sizeof(int) * n);
	for (int i = 0; i < n; i++) {
		scanf("%d",a + i);
	}
	int low = 0, high = n - 1;
	int flag = 0;
	int result = 0;
	while (low <= high) {
		int mid = low + (high - low) / 2;
		if (a[mid] > target) {
			high = mid - 1;
		}
		else if (a[mid] < target) {
			low = mid + 1;
		} 
		else {
			flag = 1;
			result = mid;
			break;
		}
	}
	if (flag) {
		printf("%d", result);
	} else{
		printf("未查找到数据");
	}
	free(a);
	a = NULL;
```

# 十五、 函数
## 介绍
面向过程的语言中最基础的单位就是函数，函数是一个代码块，拥有特定的输入接口，用于实现一个功能。

## 函数的定义和使用
    函数定义：函数类型 函数名(形参){函数体;}
    函数调用：函数名(实参);
    注意点：函数在被调用的时候，会在函数体内生成一个函数的栈帧，当函数执行完毕之后，栈帧就会被销毁，所以函数中的变量都是临时变量。


## 实参和形参
    形参：形式参数，在函数定义的时候括号中的参数
    实参：实际参数，在函数调用的时候括号中的参数


## 函数类型和返回值
    函数可以有返回值也可以没有返回值。
    函数的类型就是函数返回值的类型，可以是任意类型
    函数的返回值由return语句来给出
    如果函数没有返回值，函数的类型就是void类型，没有返回值也可以写return语句，后面直接跟分号
    return还有一个重要作用是终止函数



## 函数的递归
	递归需要满足的条件
	1、函数要自己调用自己
	2、必须要有终止条件，否则会变成死递归，造成栈溢出
### 代码演示

使用递归打印1~10
```
void Print(int num) {
	if (num > 0) {
		Print(num - 1);
		printf("%d\n", num);

	}
	return;
}
```
使用递归实现阶乘计算
```
int fun3(int num) {
	if (num > 1) {
		return  fun3(num - 1) * num;
	}
	else {
		return 1;
	}
}
```

# 十六、 指针 
## 概念
    在内存空间中每一个字节都有一个对应的编码，这个编码就是这个字节的地址，也叫做指针
    如果想要保存一个地址，应该使用用指针变量
    变量的地址：不同的类型变量应该在内存中占用不同大小的空间，比如int类型变量，占用4个字节，首地址就是变量的地址。

## 指针变量的定义
    数据类型* 指针变量名;
    注意点：指针变量的类型应该和它保存的地址对应的数据类型相同

## 运算符
    &：取址运算符，获取一个变量的地址
    *：解引用运算符，可以通过地址来获取其对应的内存中的值
