# 嵌入式学习 c语言基础 day5

# 随机数

在当前环境中，可以向系统索要一个15位的随机数，范围是[0,32767]。

#### srand:

    可以设置一个随机数种子，这个函数只有一个参数，无符号的整型来表示种子的值即可，通常会使用时间戳。
    时间戳：从1970年1月1日0时0分0秒开始到当前时间所经过的秒数

#### rand:
       
    可以获取一个随机数，没有参数，只有一个返回值，即获取到的随机数。

包含在stdlib.h头文件中


#### time:

    这个函数可以获取时间戳，包含在头文件time.h中，函数需要传递一个NULL作为参数。


具体示例：
```
	//1-10随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 10);
	}

	printf("\n");

	//10-20随机数
	for (int i = 0; i < 10; i++) {
		printf("%d\t", rand() % 11 + 10);
	}

	//如果要获取[m,n]随机数
	//要实现rand() % (m - n + 1) + m
```

# 数组

    由编译器在内存中申请一块连续的内存空间，其中每一个空间的元素类型都是相同的。

## 基本语法：
	数据类型 数组名[数组长度];

	声明静态数组，中括号里的数组长度必须是常量。

## 数组的下标：
数组的元素位置下标从0开始依次递增，

    获取第一个元素为arr[0]
    获取第4个元素为arr[3]



## 数组初始化的方式
### 完全初始化：
```
int arr[5] = {10,20,30,40,50};
int arr2[] = {1,2,3,4};//完全初始化时可以省略数组长度
```

### 不完全初始化
```
int arr[4] = {10, 20, 30} //不完全初始化，缺少的元素默认为0
```
## 修改数组元素
```
arr[2] = 30;//指定位置赋值
```

# 排序算法
##    选择排序
        原理：不断的找极值，将极值放到数组头部，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。
        
代码
```
for (int i = 0; i < n - 1; i++) {//进行n-1趟排序
		int min = a[i];
		int m_index = i;
		int temp = 0;
		for (int j = i + 1; j < n; j++) {
			if (a[j] < min) {//查找极小值位置
				min = a[j];
				m_index = j;
			}
		}
		temp = a[i];//临时变量存储当前位置值
		a[i] = min;当前位置值和最小值进行交换
		a[m_index] = temp;
	}
```
##    冒泡排序
		 原理：每一趟循环会将极值放到数组头部，剩下元素整体顺序不变，即最小的元素放在第一个位置，再从剩下的元素中找最小值，将其放在第二个位置，依次类推，完成n-1次之后，数组已然有序。
		 冒泡排序可以优化，因为可能某一趟后已经排序完成，就不需要继续排序，这时可以添加一个标志，以此来判断是否进行了交换，如果没有，可以提前结束循环
		 
代码：
```
	//未优化版本
	int temp;
	for (int i = 0; i < n - 1; i++) {//n个数只进行n-1趟排序
		for (int j = 0; j < n - 1 - i; j++) {//冒泡排序每趟能至少确定1个数的最终位置，因此后面排序用的数的数量减少
			if (a[j] > a[j + 1]) {升序排序
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
			}
		}
	}
	printf("\n");
	for (int i = 0; i < n; i++) {
		printf("%d ", a[i]);
	}




	//优化版本
	int temp;
	int i;
	for (i = 0; i < n - 1; i++) {
		int exchange = 0;//增添交换标志，如果不是完全有序，必定会交换，此时exchange=1
		for (int j = 0; j < n - 1 - i; j++) {
			if (a[j] < a[j + 1]) {
				temp = a[j];
				a[j] = a[j + 1];
				a[j + 1] = temp;
				exchange = 1;
			}
		}
		if (!exchange) {//exchange=0说明这一趟没有进行交换，也即排好序了，就不需要在进行下一轮排序了。
			break;
		}
	}

```


##    插入排序
		  原理：将数组中的元素不断的插入到一个有序的数组中，当所有的数据都插入完毕的时候，数组已然有序。
		  
代码：
```
	int i, j;
	for (i = 1; i < n; i++) {
		int temp = a[i];//存储当前值，来和前面的进行比较，然后插入
		//只有
		for (j = i; j > 0 && temp < a[j - 1]; j--) {
			a[j] = a[j - 1];
		}
		a[j] = temp;//插入
	}
```