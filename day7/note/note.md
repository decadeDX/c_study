# 嵌入式学习 c语言基础：day7

# 指针
## 概念
    在内存空间中每一个字节都有一个对应的编码，这个编码就是这个字节的地址，也叫做指针
    如果想要保存一个地址，应该使用用指针变量
    变量的地址：不同的类型变量应该在内存中占用不同大小的空间，比如int类型变量，占用4个字节，首地址就是变量的地址。

## 指针变量的定义
    数据类型* 指针变量名;
    注意点：指针变量的类型应该和它保存的地址对应的数据类型相同

## 运算符
    &：取址运算符，获取一个变量的地址
    *：解引用运算符，可以通过地址来获取其对应的内存中的值

## 多级指针

    int* p  //一级指针
    int** p  //二级指针
    int*** p  //三级指针

**注意** ：二级指针保存的是一级指针的地址，三级指针保存的是二级指针的地址

## 指针的大小
    指针大小和指针类型无关，和操作系统相关，如果是64位操作系统下的指针，占用8个字节，32位的占用4个字节

## 指针的算术运算
    指针运算，就是让当前地址进行前移或者后移操作，比如int* p指针，p+1就代表向后移动4个字节，double* p1, p1 + 1相当于向后移动8个字节，指针移动的单位和指针的类型相关。

## 常量指针和指针常量

### 常量指针

    只能改变指针的指向，不能改变指向的地址中的值  
    语法：const 类型* 指针名
    声明时可以不给初值
```
    示例：
	//可以改变指向，但不能改变值
	int a = 100, b = 200;
	const int* ptr = &a;//常量指针
	ptr = &b;
	printf("%d", *ptr);

```


### 指针常量

    不能改变指针的指向，可以改变指向的地址中的值
    语法：类型* const 指针名
    声明时必须给初值。
```
    示例：
	//可以改变值，但不能改变指向
	int* const p1 = &a;//指针常量
	*p1 = 300;
	printf("%d\t%d", *p1, a);
```

### 区分

    常量指针本质是指针，const修饰的是int*，说明整体的值不可改变，但是指针指向（即存入的地址）可以改变；

    指针常量本质是常量，const修饰的是指针本身，说明指针指向（即存入的地址）不可改变，而地址对应的值可以改变

## 空指针和野指针

###    空指针

        NULL代表空指针，就是值为0的指针。有些时候指针声明时候并不知道应该保存哪个地址，这个时候就可以将指针置为NULL。

###   野指针

        指向了不能合法访问的空间的指针就是野指针。

####   常见的场景

        没有初始化的指针
        函数返回了局部变量的指针
        数组越界的指针
        free后的指针


# 动态分配内存
##     堆空间：

        由用户手动分配释放的空间，堆空间中所有的内容都是通过指针来访问的。
##    void*类型
        void*是C语言中的万用指针类型，经常用于指针类型的中转，可以隐式转化为其他类型的指针，也可以由其他类型的指针隐式转化来。
        隐式转化是有风险的，比如使用void*可以修改一个指针的指向，比如先指向double*，再隐式转化为int*，这种情况是不合适的，所以在C++中直接限制void*的使用，需要进行强转，才能转化为其他类型的指针。

##     动态内存分配的函数

###        malloc

            头文件：stdlib.h
            函数声明：void* malloc(size_t size);  // 从堆上分配一块size字节大小的空间，返回其首地址

###         free

            函数声明：void free(void* ptr); // 释放ptr指向的堆空间中的动态空间
            free只能释放动态内存分配的地址指针，不能释放普通变量的指针

###        calloc

            函数声明 void* calloc(size_t num, size_t size) // 从堆上分配一个大小为num * size个字节的空间，初始化成0之后返回首地址

### realloc

    函数声明：void* realloc(void* ptr, size_t size); // 可以重新给一个指针分配新的空间。
    函数的操作步骤
        1、首先会在函数内部申请一个新的空间，大小就是参数2
        2、将参数1中的内容全部拷贝到函数中开辟的新空间中
        3、最后会将参数1中的空间给释放掉
        4、将申请的新空间的地址以返回值的形式返回给函数


### 指针的应用：
    
#### 一、动态内存管理（你最熟悉的场景）

##### 应用场景

    创建运行时才能确定大小的内存（比如你的动态数组），而非编译时固定大小的数组。

##### 核心价值

    突破 “静态数组大小固定” 的限制，按需分配 / 释放内存，避免内存浪费。

##### 示例（你的代码核心逻辑）
```
// 1. 动态分配内存（malloc）
int* arr = (int*)malloc(n * sizeof(int)); 

// 2. 调整内存大小（realloc）
int* new_arr = (int*)realloc(arr, sizeof(int) * (n + 1));

// 3. 释放内存（free）+ 置空指针（避免野指针）
free(*arr);
*arr = NULL;
```

#### 二、修改函数外部变量（你问的实参修改场景）

##### 应用场景

    让函数直接修改主调函数中的变量（普通变量、指针变量、数组大小等）。

##### 核心价值

    突破 C 语言 “值传递” 的限制，实现函数对外部变量的 “写操作”。

##### 示例
```
// 1. 修改普通变量
void changeInt(int* num) { *num = 100; }

// 2. 修改数组大小（你的insertNum）
void updateSize(int* size) { (*size)++; }

// 3. 修改指针变量本身（你的freeArr）
void freeAndNull(int** p) { free(*p); *p = NULL; }
```

#### 三、操作数组（数组的本质是指针）

##### 应用场景

    遍历、修改数组元素，实现数组的灵活操作（比如你的 printArr、assignArr）。

##### 核心价值

    数组名本质是 “指向首元素的常量指针”，指针运算比数组下标更灵活、效率更高。

##### 示例
```
// 数组下标方式：arr[i]
// 指针方式：*(arr + i)（等价于arr[i]，更底层）
void printArray(int* arr, int n) {
    for (int i = 0; i < n; i++) {
        printf("%d ", *(arr + i)); // 指针遍历数组
    }
}
```
#### 四、实现函数返回多个值

##### 应用场景

    C 语言函数默认只能返回一个值，用指针可以 “返回” 多个结果。

##### 核心价值

    避免用全局变量传递结果，提升代码模块化。

##### 示例

```
// 一个函数同时返回两数的和与积
void calc(int a, int b, int* sum, int* product) {
    *sum = a + b;       // 用指针返回和
    *product = a * b;   // 用指针返回积
}

int main() {
    int s, p;
    calc(3, 5, &s, &p); // 传入接收结果的变量地址
    printf("和：%d，积：%d\n", s, p); // 输出：和：8，积：15
    return 0;
}
```
#### 五、实现链表 / 树等复杂数据结构
##### 应用场景

    构建非连续存储的动态数据结构（链表、二叉树、图等）。

##### 核心价值

    这类结构需要通过指针 “链接” 不同的节点，无法用普通变量实现。

##### 示例（简单链表节点）
```
// 链表节点定义：用指针指向下一个节点
typedef struct Node {
    int data;
    struct Node* next; // 指针链接下一个节点
} Node;

// 创建新节点
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
```
### 内存泄漏：

    程序中动态分配的内存（通过malloc/calloc/realloc申请），
    在不再使用后，既没有被释放（free），也丢失了指向这块内存的指针 → 这块内存永远无法被程序回收和复用，直到程序退出，系统才会回收。


